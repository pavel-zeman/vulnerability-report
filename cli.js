#!/usr/bin/env node

const fs = require("fs");
const https = require("https");

function escapeHtml(str) {
    const escapeMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        "'": '&#39;',
        '"': '&quot;'
    };
    return str.replace(/[&<>'"]/g, tag => escapeMap[tag]);
}

function parseCommandLine() {
    if (process.argv.length <= 2) {
        console.error("Usage: vulnerability-report -i <input JSON file> -o <output HTML file> [-s <suppressions file, can be specified multiple times>]");
        process.exit(1);
    }

    // Parse command line arguments
    const options = {
        suppressionFiles: []
    };
    for (let i = 2; i < process.argv.length; i++) {
        switch (process.argv[i]) {
            case "-i":
                options.inputFile = process.argv[++i];
                break;

            case "-o":
                options.outputFile = process.argv[++i];
                break;

            case "-s":
                options.suppressionFiles.push(process.argv[++i]);
                break;

            default:
                console.error(`Invalid argument: ${process.argv[i]}`);
                process.exit(1);
        }
    }
    return options;
}

function loadSuppressions() {
    // Load suppressions
    let suppressions = {};
    options.suppressionFiles.forEach(file => {
        if (fs.existsSync(file)) {
            const suppressionData = fs.readFileSync(file);
            suppressions = { ...suppressions, ...JSON.parse(suppressionData) };
        } else {
            console.log(`Ignoring non-existent suppressions file ${file}`);
        }
    });
    return suppressions;
}


function getUrl(url) {
    return new Promise((resolve, reject) => {
        const request = https.get(url, (response) => {
            response.setEncoding("utf8");
            const resultData = [];
            response.on("data", chunk => {
                resultData.push(chunk);
            });
            response.on("end", () => resolve(resultData.join("")));
        });
        request.on("error", (e) => {
            console.error(`Error with request: ${e.message}`);
            reject("Error");
        });
        request.end();
    });
}

/**
 * Gets vulnerability title based on URL. Currently not used, because there are request rate restrictions.
 */
async function getTitle(url) {
    const result = await getUrl(url);
    const titleStartIndex = result.indexOf("<title>");
    const titleEndIndex = result.indexOf("</title>");
    if (titleStartIndex >= 0) {
        let title = result.substring(titleStartIndex + 7, titleEndIndex);
        const defaultEnding = " - Sonatype OSS Index";
        if (title.endsWith(defaultEnding)) {
            title = title.substr(0, title.length - defaultEnding.length);
        }
        return title;
    } else {
        return null;
    }
}

async function getVulnerabilityList(stringData) {
    const data = JSON.parse(stringData);
    const result = [];
    if (Array.isArray(data)) {
        // Data format as generated by https://www.npmjs.com/package/auditjs
        for(const package of data) {
            for(const vulnerability of package.vulnerabilities) {
                result.push({
                    id: vulnerability.id,
                    title: vulnerability.title,
                    reference: vulnerability.reference,
                    cvssScore: vulnerability.cvssScore,
                    description: vulnerability.description,
                    package: package.coordinates,
                });
            }
        }
    } else if (data.vulnerabilities) {
        // Data format as generated by https://github.com/sonatype-nexus-community/scan-gradle-plugin
        for(const vulnerability of data.vulnerabilities) {
            for(const affect of vulnerability.affects) {
                result.push({
                    id: vulnerability.id,
                    title: vulnerability.id,
                    reference: vulnerability.source.url,
                    cvssScore: vulnerability.ratings.length > 0 && Math.round(vulnerability.ratings[0].score * 10) / 10,
                    description: vulnerability.description,
                    package: affect.ref,
                });
            }
        }
    } else {
        // Data format as generated by uuDevKit
        Object.entries(data).forEach(item => {
            const package = item[0];
            const value = item[1];
            if (value.vulnerabilities) {
                value.vulnerabilities.forEach(vulnerability => {
                    result.push({
                        id: vulnerability.id,
                        title: vulnerability.title,
                        reference: vulnerability.reference,
                        cvssScore: vulnerability.cvssScore,
                        description: vulnerability.description,
                        package,
                    });
                });
            }
        });
    }
    return result;
}

async function generateOutput(options, suppressions) {
    // Prepare output
    let result = "<html><head>";
    result += `<style>table {
  color: #333;
  background: white;
  border: 1px solid grey;
  font-size: 10pt;
  border-collapse: collapse;
}
table thead th,
table tfoot th {
  color: #777;
  background: rgba(0,0,0,.1);
}
table caption {
  padding:.5em;
}
table th,
table td {
  padding: .5em;
  border: 1px solid lightgrey;
}</style></head>`;
    result += "<body style='font-family:sans-serif'>";

    let totalVulnerabilities = 0;
    let newVulnerabilities = 0;
    let vulnerabilities = "";
    const packageManagerPrefixes = ["pkg:maven", "pkg:npm"];

    // Generate table of vulnerabilities
    const stringData = fs.readFileSync(options.inputFile);
    (await getVulnerabilityList(stringData)).forEach(vulnerability => {
        const originalPackage = vulnerability.package;
        let pckg = originalPackage;
        packageManagerPrefixes.forEach(prefix => {
            if (pckg.startsWith(prefix)) {
                pckg = pckg.substr(prefix.length + 1);
            }
        });
        const suppression = suppressions[vulnerability.id];
        if (!suppression) {
            newVulnerabilities++;
        }
        vulnerabilities += `
            <tr>
                <td><a href="https://ossindex.sonatype.org/component/${originalPackage}">${escapeHtml(pckg)}</a></td>
                <td><a href="${vulnerability.reference}">${escapeHtml(vulnerability.title)}</a></td>
                <td style="text-align:center">${vulnerability.cvssScore}</td>
                <td>${escapeHtml(vulnerability.description)}</td>
                <td>${escapeHtml(suppression ?? "")}</td>
            </tr>
        `;
        totalVulnerabilities++;
    });

    // Generate complete result
    result += `<h1>Total vulnerabilities: ${totalVulnerabilities}, new vulnerabilities: ${newVulnerabilities}</h1>`;
    result += "<table><thead><tr><th>Package</th><th>Vulnerability</th><th>CVSS Score</th><th>Description</th><th>Comment</th></tr></thead><tbody>";
    result += vulnerabilities;
    result += "</tbody></table></body>";

    fs.writeFileSync(options.outputFile, result);

    console.log(`##teamcity[buildStatus text='Total vulnerabilities: ${totalVulnerabilities}, new vulnerabilities: ${newVulnerabilities}']`);

    // Exit with non-zero code to indicate, that new vulnerabilities have been found
    process.exit(newVulnerabilities > 0 ? 1 : 0);
}

const options = parseCommandLine();
const suppressions = loadSuppressions();
generateOutput(options, suppressions);
